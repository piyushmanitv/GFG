Maximum Stone Removal
Difficulty: MediumAccuracy: 49.82%Submissions: 22K+Points: 4Average Time: 30m
Given an 2D array of non-negative integers stones[][] where stones[i] = [xi , yi] represents the location of the ith stone on a 2D plane, the task is to return the maximum possible number of stones that you can remove.

A stone can be removed if it shares either the same row or the same column as another stone that has not been removed.

Note: Each coordinate point may have at most one stone.










class Solution {
    int f(int n, vector<int> &p) {
        if(p[n] == -1) return n;
        return p[n] = f(p[n], p);
    }
  public:
    int maxRemove(vector<vector<int>> &stones) {
        // Code here
        int n = stones.size(), r = 0, c = 0, ans = 0;
        for(int i = 0; i < n; i++) {
            r = max(r, stones[i][0]);
            c = max(c, stones[i][1]);
        }
        vector<int> p(r + c + 2, -1), s(r + c + 2, 0);
        for(int i = 0; i < n; i++) {
            int u = f(stones[i][0], p);
            int v = f(stones[i][1] + r + 1, p);
            if(s[u] < s[v]) swap(u, v);
            s[u]++;
            if(u != v) {
                p[v] = u;
                s[u] += s[v];
            }
        }
        for(int i = 0; i < r + c + 2; i++) {
            if(p[i] == -1 && s[i] - 1 > 0) ans += (s[i] - 1);
        }
        
        return ans;
    }
};
